/* Generated by Together */
#include "StdAfx.h"

#include "CManuverBuilder.h"
#include "CManuver.h"
#include "..\..\PlanePathTest\src\CPlanePreferences.h"
#include "IPlane.h"


CManuverBuilder theManuverBuilder;
static const std::string szFileName = "PlaneManuvers.xml";
// /////////////////////////////////////////////////////////////////////////
std::vector<int> CManuverBuilder::suitableIndeces;
CManuverStateDescriptor CManuverBuilder::state;
// /////////////////////////////////////////////////////////////////////////
int CManuverDescriptor::operator&( IStructureSaver &ss )
{
	CSaverAccessor saver = &ss;
	saver.Add( 1, &parameters );
	saver.Add( 2, &id );
	saver.Add( 3, &point );
	saver.Add( 4, &att );
	return 0;
}

// /////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////
// CManuverStateDescriptor
// /////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////
void CManuverStateDescriptor::Init( const enum EPlanesAttitude _att, interface IPlane *pPos, interface IPlane *pEnemy )
{
	att = _att;
	
	const CVec3 vSpeed1 = pPos->GetSpeedB2();
	const CVec3 vPos1 = pPos->GetPosB2();
	const CVec3 vSpeed2 = pEnemy->GetSpeedB2();
	const CVec3 vPos2 = pEnemy->GetPosB2();
	const CVec3 vDist = vPos2 - vPos1;
	const CPlanePreferences &pref1 = pPos->GetPreferencesB2();
	const CPlanePreferences &pref2 = pEnemy->GetPreferencesB2();
	const float fTurnR1 = pref1.GetR( fabs( vSpeed1 ) );
	

	parameters[EPID_ENEMY_DIRECTION] = DirsDifference( GetDirectionByVector( vSpeed1.x, vSpeed1.y ),
																										 GetDirectionByVector( vDist.x, vDist.y ) ) * 2.0f / 65536.0f;
	
	parameters[EPID_PLANE_DIRECTION] = DirsDifference( GetDirectionByVector( vSpeed2.x, vSpeed2.y ),
																										 GetDirectionByVector( -vDist.x, -vDist.y ) ) * 2.0f / 65536.0f;

	parameters[EPID_DIRS_DIFFERENCE] = DirsDifference( GetDirectionByVector( vSpeed2.x, vSpeed2.y ), GetDirectionByVector( vSpeed1.x, vSpeed1.y ) ) * 2.0f / 65536.0f;

	parameters[EPID_DISTANCE] = fabs( vDist ) / fTurnR1;
	parameters[EPID_SELF_HEIGHT] = ( vPos1.z - SConsts::PLANE_MIN_HEIGHT ) / fTurnR1;
	parameters[EPID_HEIGHT_DIFF] = ( vPos2.z - vPos1.z ) / fTurnR1;
	parameters[EPID_SELF_SPEED] = ( fabs( vSpeed1 ) - pref1.GetStallSpeed() ) / pref1.GetMaxSpeed();
	parameters[EPID_ENEMY_SPEED] = ( fabs( vSpeed2 ) - pref2.GetStallSpeed() ) / pref2.GetMaxSpeed();
}
// /////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////
// CManoverBuilder
// /////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////
#define STRING_ENUM_ADD(TypeConverter,eEnum) TypeConverter[#eEnum] = eEnum;
// /////////////////////////////////////////////////////////////////////////
void CManuverBuilder::Init()
{
	std::hash_map<std::string,int> loadHelper;
	// manuver ID
	STRING_ENUM_ADD( loadHelper, EMID_GENERIC )
	STRING_ENUM_ADD( loadHelper, EMID_STEEPCLIMB )

	// point ID
	STRING_ENUM_ADD( loadHelper, EMD_PREDICTED_POINT )
	STRING_ENUM_ADD( loadHelper, EMD_MANUVER_DEPENDENT )

	// attitude
	STRING_ENUM_ADD( loadHelper, EPA_ATTACK )
	STRING_ENUM_ADD( loadHelper, EPA_RETREAT )
	
	STRING_ENUM_ADD( loadHelper, ESR_NEAR_STALL )
	STRING_ENUM_ADD( loadHelper, ESR_SMALL )
	STRING_ENUM_ADD( loadHelper, ESR_NORMAL )
	STRING_ENUM_ADD( loadHelper, ESR_MAXIMUM )

 /* for creation of empty file	
	 */

	// load manuver's descriptions.
	// descriptors
	std::vector<SManuverDescriptorForLoad> forLoad;
	CPtr<IDataStream> pStream = GetSingleton<IDataStorage>()->OpenStream( szFileName.c_str(), STREAM_ACCESS_READ );
	NI_ASSERT_T( pStream != 0, NStr::Format( "can't open file \"%s\"", szFileName.c_str() ) );
	CTreeAccessor tree = CreateDataTreeSaver( pStream, IDataTree::READ );
	tree.Add( "Manuvers", &forLoad );
	
	descriptors.resize( forLoad.size() );
	int i = 0;
	for ( std::vector<SManuverDescriptorForLoad>::iterator it = forLoad.begin(); it != forLoad.end(); ++it )
	{
		NI_ASSERT_T( loadHelper.find( it->szID ) != loadHelper.end(), NStr::Format( "unregistered string \"%s\"", it->szID.c_str() ) );
		NI_ASSERT_T( loadHelper.find( it->szPoint ) != loadHelper.end(), NStr::Format( "unregistered string \"%s\"", it->szPoint.c_str() ) );
		NI_ASSERT_T( loadHelper.find( it->szAtt ) != loadHelper.end(), NStr::Format( "unregistered string \"%s\"", it->szAtt.c_str() ) );
	
		descriptors[i++].Init( loadHelper[it->szID], loadHelper[it->szPoint], loadHelper[it->szAtt], it->parameters );
	}

	const int nDescs = descriptors.size();
	for ( int m = 0; m < nDescs; ++m )
		manuvers[descriptors[m].GetAtt()].push_back( m );

	suitableIndeces.reserve( nDescs );

}
// /////////////////////////////////////////////////////////////////////////
const CManuverDescriptor *CManuverBuilder::Choose( const CManuverStateDescriptor &current ) const
{
	CManuvers::const_iterator manuverIter = manuvers.find( current.GetAtt() );
	
	suitableIndeces.clear();
	
	if ( manuverIter != manuvers.end() )
	{
		const CManuverIndices &indices = manuverIter->second;
		
		for ( CManuverIndices::const_iterator it = indices.begin(); it != indices.end(); ++it )
		{
			if ( descriptors[*it].CheckSuitable( current ) )
				suitableIndeces.push_back( *it );
		}
	}
	if ( !suitableIndeces.empty() )
	{
		// CRAP{ TO DO
		// choose manuver by random
		// CRAP}
		return &descriptors[*suitableIndeces.begin()];
	}

	return 0;
}
// /////////////////////////////////////////////////////////////////////////
interface IManuver * CManuverBuilder::CreateDefaultManuver( const enum EPlanesAttitude att, interface IPlane *pPos, interface IPlane *pEnemy ) const
{
	if ( EPA_RETREAT == att )
	{
		// horizontal manuver in random direction
		const CVec3 vSpeed( pPos->GetSpeedB2() );
		const float fSpeed( fabs( vSpeed ) );
		CVec3 vPerp ( -vSpeed.y, vSpeed.x, 0 );
		Normalize( &vPerp );
		vPerp *= ( Random(0,1) == 1 ? -1 : 1 );

		const CVec3 vPoint( pPos->GetPosB2() + 2.1f * vPerp * pPos->GetPreferencesB2().GetR( fSpeed ) );
		return CreatePointManuver( pPos, vPoint );
	}
	else
	{
		// aim to predicted point
		return CreatePointManuver( pPos, CManuver::CalcPredictedPoint( pPos, pEnemy ) );
	}
}
	
// /////////////////////////////////////////////////////////////////////////
interface IManuver* CManuverBuilder::CreatePointManuver ( interface IPlane *pPos, const CVec3 &vPoint ) const
{
	CManuverGeneric *pHor = new CManuverGeneric;
	pHor->Init( pPos, vPoint );
	return pHor;
}
// /////////////////////////////////////////////////////////////////////////
EPlanesAttitude CManuverBuilder::GetAttitude( interface IPlane *pPlane, interface IPlane *pEnemy ) const
{ 
	if ( pPlane->IsBeingAttackedB2()  )
		return EPA_RETREAT;
	return EPA_ATTACK;
}
// /////////////////////////////////////////////////////////////////////////
interface IManuver* CManuverBuilder::CreateManuver ( interface IPlane *pPos, interface IPlane *pEnemy ) const
{
	EPlanesAttitude att = GetAttitude( pPos, pEnemy );
	state.Init( att, pPos, pEnemy );

	const CManuverDescriptor *pDesc = Choose( state );
	if ( pDesc )
	{
		// create manuver according to descriptor and return
		IManuver * pManuver = CreateObject<IManuver>( pDesc->GetManuverID() );
		pManuver->Init( pDesc->GetDestination(), pPos, pEnemy );
		return pManuver;
	}
	else
		return CreateDefaultManuver( att, pPos, pEnemy );
}
